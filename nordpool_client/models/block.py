# coding: utf-8

"""
    Auction API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class Block(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'name': 'str',
        'price': 'float',
        'minimum_acceptance_ratio': 'float',
        'linked_to': 'str',
        'is_spread_block': 'bool',
        'exclusive_group': 'str',
        'periods': 'list[Period]'
    }

    attribute_map = {
        'name': 'name',
        'price': 'price',
        'minimum_acceptance_ratio': 'minimumAcceptanceRatio',
        'linked_to': 'linkedTo',
        'is_spread_block': 'isSpreadBlock',
        'exclusive_group': 'exclusiveGroup',
        'periods': 'periods'
    }

    def __init__(self, name=None, price=None, minimum_acceptance_ratio=None, linked_to=None, is_spread_block=None, exclusive_group=None, periods=None):  # noqa: E501
        """Block - a model defined in Swagger"""  # noqa: E501
        self._name = None
        self._price = None
        self._minimum_acceptance_ratio = None
        self._linked_to = None
        self._is_spread_block = None
        self._exclusive_group = None
        self._periods = None
        self.discriminator = None
        self.name = name
        self.price = price
        self.minimum_acceptance_ratio = minimum_acceptance_ratio
        if linked_to is not None:
            self.linked_to = linked_to
        if is_spread_block is not None:
            self.is_spread_block = is_spread_block
        if exclusive_group is not None:
            self.exclusive_group = exclusive_group
        self.periods = periods

    @property
    def name(self):
        """Gets the name of this Block.  # noqa: E501

        Block name (40 characters max)  # noqa: E501

        :return: The name of this Block.  # noqa: E501
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this Block.

        Block name (40 characters max)  # noqa: E501

        :param name: The name of this Block.  # noqa: E501
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501

        self._name = name

    @property
    def price(self):
        """Gets the price of this Block.  # noqa: E501

        Block price in currency assigned to order portfolio.  # noqa: E501

        :return: The price of this Block.  # noqa: E501
        :rtype: float
        """
        return self._price

    @price.setter
    def price(self, price):
        """Sets the price of this Block.

        Block price in currency assigned to order portfolio.  # noqa: E501

        :param price: The price of this Block.  # noqa: E501
        :type: float
        """
        if price is None:
            raise ValueError("Invalid value for `price`, must not be `None`")  # noqa: E501

        self._price = price

    @property
    def minimum_acceptance_ratio(self):
        """Gets the minimum_acceptance_ratio of this Block.  # noqa: E501

        Minimum acceptance ratio allows to define lowest possible acceptance degree. Valid values are 0 and up to 1, where 0 means fully curtailable and 1 means not curtailable.  # noqa: E501

        :return: The minimum_acceptance_ratio of this Block.  # noqa: E501
        :rtype: float
        """
        return self._minimum_acceptance_ratio

    @minimum_acceptance_ratio.setter
    def minimum_acceptance_ratio(self, minimum_acceptance_ratio):
        """Sets the minimum_acceptance_ratio of this Block.

        Minimum acceptance ratio allows to define lowest possible acceptance degree. Valid values are 0 and up to 1, where 0 means fully curtailable and 1 means not curtailable.  # noqa: E501

        :param minimum_acceptance_ratio: The minimum_acceptance_ratio of this Block.  # noqa: E501
        :type: float
        """
        if minimum_acceptance_ratio is None:
            raise ValueError("Invalid value for `minimum_acceptance_ratio`, must not be `None`")  # noqa: E501

        self._minimum_acceptance_ratio = minimum_acceptance_ratio

    @property
    def linked_to(self):
        """Gets the linked_to of this Block.  # noqa: E501

        Name of the block this block is linked to. Is NULL for regular or parent block.  # noqa: E501

        :return: The linked_to of this Block.  # noqa: E501
        :rtype: str
        """
        return self._linked_to

    @linked_to.setter
    def linked_to(self, linked_to):
        """Sets the linked_to of this Block.

        Name of the block this block is linked to. Is NULL for regular or parent block.  # noqa: E501

        :param linked_to: The linked_to of this Block.  # noqa: E501
        :type: str
        """

        self._linked_to = linked_to

    @property
    def is_spread_block(self):
        """Gets the is_spread_block of this Block.  # noqa: E501

        Specify if current block is one of Spread blocks pair. Only required for spread block. Requires field \"linkedTo\" to contain name of another spread block in pair.  # noqa: E501

        :return: The is_spread_block of this Block.  # noqa: E501
        :rtype: bool
        """
        return self._is_spread_block

    @is_spread_block.setter
    def is_spread_block(self, is_spread_block):
        """Sets the is_spread_block of this Block.

        Specify if current block is one of Spread blocks pair. Only required for spread block. Requires field \"linkedTo\" to contain name of another spread block in pair.  # noqa: E501

        :param is_spread_block: The is_spread_block of this Block.  # noqa: E501
        :type: bool
        """

        self._is_spread_block = is_spread_block

    @property
    def exclusive_group(self):
        """Gets the exclusive_group of this Block.  # noqa: E501

        Name of Exclusive Ggroup this block belongs to. Equal to NULL if doesn't belong to any Exclusive Group.  # noqa: E501

        :return: The exclusive_group of this Block.  # noqa: E501
        :rtype: str
        """
        return self._exclusive_group

    @exclusive_group.setter
    def exclusive_group(self, exclusive_group):
        """Sets the exclusive_group of this Block.

        Name of Exclusive Ggroup this block belongs to. Equal to NULL if doesn't belong to any Exclusive Group.  # noqa: E501

        :param exclusive_group: The exclusive_group of this Block.  # noqa: E501
        :type: str
        """

        self._exclusive_group = exclusive_group

    @property
    def periods(self):
        """Gets the periods of this Block.  # noqa: E501

        List of block periods.  # noqa: E501

        :return: The periods of this Block.  # noqa: E501
        :rtype: list[Period]
        """
        return self._periods

    @periods.setter
    def periods(self, periods):
        """Sets the periods of this Block.

        List of block periods.  # noqa: E501

        :param periods: The periods of this Block.  # noqa: E501
        :type: list[Period]
        """
        if periods is None:
            raise ValueError("Invalid value for `periods`, must not be `None`")  # noqa: E501

        self._periods = periods

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Block, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Block):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
